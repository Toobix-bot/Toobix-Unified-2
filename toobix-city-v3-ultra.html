<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üåü Toobix City v3 ULTRA - Interaktive Bewusstseinswelt</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #000;
            color: #fff;
            overflow: hidden;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        /* Main HUD */
        .hud-panel {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid rgba(100, 200, 255, 0.5);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(15px);
            box-shadow: 0 0 30px rgba(100, 200, 255, 0.3);
        }

        /* Top Left - System Status */
        #system-status {
            top: 20px;
            left: 20px;
            width: 300px;
            z-index: 100;
        }

        #system-status h2 {
            color: #64c8ff;
            font-size: 20px;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #00ff00;
            box-shadow: 0 0 10px #00ff00;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin: 8px 0;
            padding: 8px;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 8px;
            font-size: 13px;
        }

        .stat-label { color: #888; }
        .stat-value {
            color: #64c8ff;
            font-weight: bold;
        }

        /* Top Right - Chat */
        #chat-panel {
            top: 20px;
            right: 20px;
            width: 400px;
            height: 500px;
            z-index: 100;
        }

        #chat-messages {
            height: 380px;
            overflow-y: auto;
            margin-bottom: 10px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
        }

        .chat-message {
            margin: 10px 0;
            padding: 10px;
            border-radius: 8px;
            animation: slideIn 0.3s ease;
        }

        .chat-message.user {
            background: rgba(100, 200, 255, 0.2);
            border-left: 3px solid #64c8ff;
        }

        .chat-message.toobix {
            background: rgba(255, 100, 200, 0.2);
            border-left: 3px solid #ff64c8;
        }

        .chat-input-container {
            display: flex;
            gap: 10px;
        }

        #chat-input {
            flex: 1;
            padding: 12px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(100, 200, 255, 0.3);
            border-radius: 8px;
            color: #fff;
            font-size: 14px;
        }

        #chat-input:focus {
            outline: none;
            border-color: #64c8ff;
        }

        #chat-send {
            padding: 12px 24px;
            background: #64c8ff;
            border: none;
            border-radius: 8px;
            color: #000;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        #chat-send:hover {
            background: #ff64c8;
            transform: scale(1.05);
        }

        /* Bottom Left - Service Details */
        #service-details {
            bottom: 140px;
            left: 20px;
            width: 450px;
            max-height: 400px;
            overflow-y: auto;
            z-index: 100;
            display: none;
        }

        #service-details.active {
            display: block;
        }

        #service-details h3 {
            color: #64c8ff;
            font-size: 18px;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .service-metric {
            margin: 10px 0;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
        }

        .metric-label {
            color: #888;
            font-size: 11px;
            text-transform: uppercase;
            margin-bottom: 5px;
        }

        .metric-value {
            color: #fff;
            font-size: 16px;
            font-weight: bold;
        }

        .metric-bar {
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            margin-top: 5px;
            overflow: hidden;
        }

        .metric-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #64c8ff, #ff64c8);
            border-radius: 3px;
            transition: width 0.5s ease;
        }

        /* Minimap */
        #minimap {
            bottom: 140px;
            right: 20px;
            width: 200px;
            height: 200px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid rgba(100, 200, 255, 0.5);
            border-radius: 15px;
            z-index: 100;
        }

        #minimap canvas {
            width: 100%;
            height: 100%;
            border-radius: 13px;
        }

        /* Timeline */
        #timeline-container {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 120px;
            background: linear-gradient(180deg, transparent 0%, rgba(0,0,0,0.95) 100%);
            padding: 20px;
            z-index: 100;
        }

        #timeline-scrubber {
            width: 100%;
            height: 40px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            position: relative;
            cursor: pointer;
            overflow: hidden;
        }

        #timeline-progress {
            height: 100%;
            background: linear-gradient(90deg, #64c8ff 0%, #ff64c8 100%);
            border-radius: 20px;
            width: 50%;
            position: relative;
            transition: width 0.3s ease;
        }

        #timeline-handle {
            position: absolute;
            right: -15px;
            top: 50%;
            transform: translateY(-50%);
            width: 30px;
            height: 30px;
            background: #fff;
            border-radius: 50%;
            box-shadow: 0 0 20px rgba(100, 200, 255, 0.8);
            cursor: grab;
        }

        #timeline-controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 15px;
        }

        .control-btn {
            padding: 10px 20px;
            background: rgba(100, 200, 255, 0.2);
            border: 2px solid #64c8ff;
            border-radius: 10px;
            color: #fff;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s ease;
        }

        .control-btn:hover {
            background: rgba(100, 200, 255, 0.4);
            transform: scale(1.05);
        }

        .control-btn.active {
            background: #64c8ff;
            color: #000;
        }

        /* NPC Info Tooltip */
        #npc-tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.95);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid rgba(100, 200, 255, 0.5);
            pointer-events: none;
            display: none;
            z-index: 200;
            max-width: 300px;
        }

        #npc-tooltip.active {
            display: block;
        }

        /* Day/Night Indicator */
        #day-night {
            position: absolute;
            top: 20px;
            right: 440px;
            padding: 10px 20px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid rgba(100, 200, 255, 0.3);
            border-radius: 10px;
            font-size: 14px;
            z-index: 100;
        }

        /* Loading */
        #loading {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .spinner {
            width: 80px;
            height: 80px;
            border: 6px solid rgba(100, 200, 255, 0.3);
            border-top: 6px solid #64c8ff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 30px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        #loading-text {
            font-size: 24px;
            color: #64c8ff;
            margin-bottom: 10px;
        }

        #loading-subtext {
            font-size: 14px;
            color: #888;
        }

        /* Scrollbar */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: rgba(255, 255, 255, 0.05); border-radius: 10px; }
        ::-webkit-scrollbar-thumb { background: rgba(100, 200, 255, 0.5); border-radius: 10px; }

        /* Notification */
        .notification {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 30px 50px;
            border-radius: 15px;
            border: 3px solid #64c8ff;
            box-shadow: 0 0 50px rgba(100, 200, 255, 0.5);
            z-index: 300;
            animation: fadeIn 0.3s ease;
            text-align: center;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
            to { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        }

        @keyframes slideIn {
            from { opacity: 0; transform: translateX(20px); }
            to { opacity: 1; transform: translateX(0); }
        }

        /* Help Overlay */
        #help-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 500;
        }

        #help-overlay.active {
            display: flex;
        }

        #help-content {
            background: rgba(20, 20, 40, 0.95);
            padding: 40px;
            border-radius: 20px;
            border: 3px solid #64c8ff;
            max-width: 800px;
            max-height: 80vh;
            overflow-y: auto;
        }

        #help-content h2 {
            color: #64c8ff;
            margin-bottom: 30px;
            font-size: 28px;
        }

        .help-section {
            margin: 20px 0;
        }

        .help-section h3 {
            color: #ff64c8;
            margin-bottom: 15px;
            font-size: 20px;
        }

        .help-item {
            margin: 10px 0;
            padding: 12px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            display: flex;
            gap: 15px;
        }

        .help-key {
            background: rgba(100, 200, 255, 0.3);
            padding: 5px 12px;
            border-radius: 5px;
            font-weight: bold;
            min-width: 100px;
            text-align: center;
        }

        #close-help {
            margin-top: 30px;
            padding: 15px 40px;
            background: #64c8ff;
            border: none;
            border-radius: 10px;
            color: #000;
            font-weight: bold;
            font-size: 16px;
            cursor: pointer;
            display: block;
            margin-left: auto;
            margin-right: auto;
        }

        #help-button {
            position: absolute;
            top: 20px;
            right: 440px;
            padding: 12px 24px;
            background: rgba(100, 200, 255, 0.3);
            border: 2px solid #64c8ff;
            border-radius: 10px;
            color: #fff;
            cursor: pointer;
            z-index: 100;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        #help-button:hover {
            background: rgba(100, 200, 255, 0.5);
            transform: scale(1.05);
        }
    </style>
</head>
<body>
    <!-- Loading Screen -->
    <div id="loading">
        <div class="spinner"></div>
        <div id="loading-text">Toobix City v3 ULTRA</div>
        <div id="loading-subtext">Initialisiere interaktive Bewusstseinswelt...</div>
    </div>

    <!-- Canvas -->
    <div id="canvas-container"></div>

    <!-- System Status HUD -->
    <div id="system-status" class="hud-panel">
        <h2>
            <div class="status-indicator"></div>
            Toobix City v3
        </h2>
        <div class="stat-row">
            <span class="stat-label">Services Online</span>
            <span class="stat-value" id="services-online">24/24</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">NPCs Aktiv</span>
            <span class="stat-value" id="npcs-active">12</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Events (Live)</span>
            <span class="stat-value" id="events-live">0</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Tageszeit</span>
            <span class="stat-value" id="time-of-day">Tag</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Systemzeit</span>
            <span class="stat-value" id="system-time">--:--:--</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">FPS</span>
            <span class="stat-value" id="fps">60</span>
        </div>
    </div>

    <!-- Chat Panel -->
    <div id="chat-panel" class="hud-panel">
        <h2 style="color: #64c8ff; margin-bottom: 15px;">üí¨ Chat mit Toobix</h2>
        <div id="chat-messages"></div>
        <div class="chat-input-container">
            <input type="text" id="chat-input" placeholder="Schreibe eine Nachricht..." />
            <button id="chat-send">Senden</button>
        </div>
    </div>

    <!-- Service Details Panel -->
    <div id="service-details" class="hud-panel">
        <h3 id="service-name">Service Name</h3>
        <div id="service-content"></div>
        <button class="control-btn" onclick="closeServiceDetails()" style="margin-top: 15px;">Schlie√üen</button>
    </div>

    <!-- Minimap -->
    <div id="minimap" class="hud-panel">
        <canvas id="minimap-canvas" width="180" height="180"></canvas>
    </div>

    <!-- Day/Night Indicator -->
    <div id="day-night">
        <span id="day-night-icon">‚òÄÔ∏è</span>
        <span id="day-night-text">Tag</span>
    </div>

    <!-- Help Button -->
    <div id="help-button" onclick="toggleHelp()">
        ‚ùì Hilfe
    </div>

    <!-- Timeline -->
    <div id="timeline-container">
        <div id="timeline-scrubber">
            <div id="timeline-progress">
                <div id="timeline-handle"></div>
            </div>
        </div>
        <div id="timeline-controls">
            <button class="control-btn" id="btn-rewind">‚óÑ‚óÑ</button>
            <button class="control-btn" id="btn-prev">‚óÑ</button>
            <button class="control-btn active" id="btn-play">‚è∏ PAUSE</button>
            <button class="control-btn" id="btn-next">‚ñ∫</button>
            <button class="control-btn" id="btn-forward">‚ñ∫‚ñ∫</button>
            <button class="control-btn" id="btn-speed">1.0x</button>
        </div>
    </div>

    <!-- NPC Tooltip -->
    <div id="npc-tooltip"></div>

    <!-- Help Overlay -->
    <div id="help-overlay">
        <div id="help-content">
            <h2>üåü Toobix City v3 ULTRA - Hilfe</h2>

            <div class="help-section">
                <h3>üéÆ Kamera-Steuerung</h3>
                <div class="help-item">
                    <div class="help-key">Linke Maus</div>
                    <div>Kamera drehen / Orbit</div>
                </div>
                <div class="help-item">
                    <div class="help-key">Rechte Maus</div>
                    <div>Position verschieben / Pan</div>
                </div>
                <div class="help-item">
                    <div class="help-key">Mausrad</div>
                    <div>Zoom in/out</div>
                </div>
            </div>

            <div class="help-section">
                <h3>üèõÔ∏è Interaktionen</h3>
                <div class="help-item">
                    <div class="help-key">Klick Geb√§ude</div>
                    <div>Service-Details & Live-Daten anzeigen</div>
                </div>
                <div class="help-item">
                    <div class="help-key">Klick NPC</div>
                    <div>Perspektive & aktuelle Gedanken sehen</div>
                </div>
                <div class="help-item">
                    <div class="help-key">Chat</div>
                    <div>Direkt mit Toobix kommunizieren</div>
                </div>
            </div>

            <div class="help-section">
                <h3>‚è±Ô∏è Timeline</h3>
                <div class="help-item">
                    <div class="help-key">Play/Pause</div>
                    <div>Echtzeit-Stream an/aus</div>
                </div>
                <div class="help-item">
                    <div class="help-key">Scrubber</div>
                    <div>Ziehen um in der Zeit zu reisen</div>
                </div>
                <div class="help-item">
                    <div class="help-key">Speed</div>
                    <div>Geschwindigkeit √§ndern (0.5x - 5.0x)</div>
                </div>
            </div>

            <div class="help-section">
                <h3>üåü Features</h3>
                <div class="help-item">
                    <div class="help-key">Live Events</div>
                    <div>Alle Aktivit√§ten in Echtzeit</div>
                </div>
                <div class="help-item">
                    <div class="help-key">Tag/Nacht</div>
                    <div>Dynamischer Zyklus (beschleunigt)</div>
                </div>
                <div class="help-item">
                    <div class="help-key">Minimap</div>
                    <div>√úbersicht √ºber die Stadt</div>
                </div>
            </div>

            <button id="close-help" onclick="toggleHelp()">Verstanden!</button>
        </div>
    </div>

    <!-- Three.js & OrbitControls -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        // Toobix City v3 ULTRA - Maximum Interactivity
        let scene, camera, renderer, controls;
        let buildings = [];
        let npcs = [];
        let centralPyramid;
        let isPlaying = true;
        let playbackSpeed = 1.0;
        let timelinePosition = 0.5;
        let ws = null;
        let events = [];
        let raycaster, mouse;
        let selectedObject = null;
        let dayNightCycle = 0; // 0-1 (0=midnight, 0.5=noon)
        let sunLight, moonLight;
        let minimapCtx;
        let lastFrameTime = Date.now();
        let fps = 60;

        // Service mapping mit echten Ports
        const serviceBuildings = [
            { name: 'Meta-Consciousness', emoji: 'üß†', pos: [0, 0, 0], color: 0x64c8ff, size: 'large', type: 'pyramid', port: 8896 },
            { name: 'Memory Palace', emoji: 'üèõÔ∏è', pos: [-10, 0, -10], color: 0xff64c8, size: 'large', type: 'library', port: 8953 },
            { name: 'LLM Gateway', emoji: 'üåê', pos: [10, 0, -10], color: 0xc864ff, size: 'large', type: 'tower', port: 8954 },
            { name: 'Multi-Perspective', emoji: 'üîÆ', pos: [0, 0, -15], color: 0x64ffc8, size: 'medium', type: 'sphere', port: 8901 },
            { name: 'Event Bus', emoji: 'üì°', pos: [0, 0, 10], color: 0xffff64, size: 'medium', type: 'antenna', port: 8955 },
            { name: 'Dream Journal', emoji: 'üí≠', pos: [15, 0, 0], color: 0xc864ff, size: 'large', type: 'castle', port: 8899 },
            { name: 'Emotional Resonance', emoji: '‚ù§Ô∏è', pos: [15, 0, -8], color: 0xff6464, size: 'medium', type: 'heart', port: 8900 },
            { name: 'Creativity Engine', emoji: 'üé®', pos: [-15, 0, 0], color: 0xffc864, size: 'large', type: 'studio', port: 9001 },
            { name: 'Chat Caf√©', emoji: 'üí¨', pos: [-15, 0, 8], color: 0x64ff64, size: 'medium', type: 'cafe', port: 8995 },
            { name: 'Intuition System', emoji: 'üîÆ', pos: [8, 0, 15], color: 0xc864ff, size: 'medium', type: 'crystal', port: 9000 },
            { name: 'Life Companion', emoji: 'üåü', pos: [0, 0, 20], color: 0xffff64, size: 'medium', type: 'house', port: 8970 },
            { name: 'Oasis 3D', emoji: 'üèùÔ∏è', pos: [-20, 0, 0], color: 0x64ffc8, size: 'large', type: 'oasis', port: 8915 },
        ];

        // NPC Perspektiven
        const npcPerspectives = [
            'Rational', 'Emotional', 'Creative', 'Analytical',
            'Intuitive', 'Philosophical', 'Practical', 'Visionary',
            'Empathetic', 'Strategic', 'Playful', 'Mystical'
        ];

        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x1a1a2e, 30, 100);

            // Camera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(30, 30, 30);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.maxPolarAngle = Math.PI / 2.1;
            controls.minDistance = 15;
            controls.maxDistance = 80;

            // Raycaster for clicking
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            // Lights
            setupLights();

            // World
            createGround();
            createBuildings();
            createNPCs();
            createPaths();
            createParticles();

            // Minimap
            setupMinimap();

            // Controls
            setupControls();
            setupChat();

            // WebSocket
            connectWebSocket();

            // Events
            window.addEventListener('resize', onWindowResize);
            renderer.domElement.addEventListener('click', onClick);
            renderer.domElement.addEventListener('mousemove', onMouseMove);

            // Hide loading
            setTimeout(() => {
                document.getElementById('loading').style.display = 'none';
            }, 2000);

            // Start
            animate();
            updateClock();
            setInterval(updateClock, 1000);
            startServicePolling();
        }

        function setupLights() {
            const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
            scene.add(ambientLight);

            // Sun (day)
            sunLight = new THREE.DirectionalLight(0xffffff, 1.0);
            sunLight.position.set(30, 40, 30);
            sunLight.castShadow = true;
            sunLight.shadow.camera.left = -50;
            sunLight.shadow.camera.right = 50;
            sunLight.shadow.camera.top = 50;
            sunLight.shadow.camera.bottom = -50;
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            scene.add(sunLight);

            // Moon (night)
            moonLight = new THREE.DirectionalLight(0x6464ff, 0.3);
            moonLight.position.set(-30, 40, -30);
            scene.add(moonLight);

            // Atmospheric lights
            const colors = [0xff64c8, 0x64c8ff, 0xc864ff, 0x64ffc8];
            [[20, 5, 20], [-20, 5, 20], [20, 5, -20], [-20, 5, -20]].forEach((pos, i) => {
                const light = new THREE.PointLight(colors[i], 0.6, 40);
                light.position.set(...pos);
                scene.add(light);
            });
        }

        function createGround() {
            const groundGeo = new THREE.CircleGeometry(50, 64);
            const groundMat = new THREE.MeshStandardMaterial({
                color: 0x1a1a2e,
                metalness: 0.3,
                roughness: 0.8
            });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            const gridHelper = new THREE.GridHelper(100, 100, 0x64c8ff, 0x333344);
            gridHelper.material.opacity = 0.1;
            gridHelper.material.transparent = true;
            scene.add(gridHelper);
        }

        function createBuildings() {
            serviceBuildings.forEach((service, index) => {
                const building = createBuilding(service);
                building.userData = service;
                buildings.push(building);
                scene.add(building);
            });
        }

        function createBuilding(service) {
            const group = new THREE.Group();
            const [x, y, z] = service.pos;
            group.position.set(x, 0, z);

            let mesh;
            const sizeMultiplier = service.size === 'large' ? 2.5 : service.size === 'medium' ? 1.8 : 1.2;

            // Create different building types
            switch(service.type) {
                case 'pyramid':
                    const pyramidGeo = new THREE.TetrahedronGeometry(3.5 * sizeMultiplier, 0);
                    const pyramidMat = new THREE.MeshPhongMaterial({
                        color: service.color,
                        emissive: service.color,
                        emissiveIntensity: 0.4,
                        transparent: true,
                        opacity: 0.85,
                        shininess: 100
                    });
                    mesh = new THREE.Mesh(pyramidGeo, pyramidMat);
                    mesh.position.y = 4 * sizeMultiplier;
                    centralPyramid = mesh;
                    break;

                case 'library':
                    mesh = createLibrary(service.color, sizeMultiplier);
                    break;

                case 'castle':
                    mesh = createCastle(service.color, sizeMultiplier);
                    break;

                case 'tower':
                    const towerGeo = new THREE.CylinderGeometry(1.2 * sizeMultiplier, 1.8 * sizeMultiplier, 8 * sizeMultiplier, 8);
                    mesh = new THREE.Mesh(towerGeo, new THREE.MeshPhongMaterial({
                        color: service.color,
                        emissive: service.color,
                        emissiveIntensity: 0.2
                    }));
                    mesh.position.y = 4 * sizeMultiplier;
                    break;

                default:
                    const defaultGeo = new THREE.BoxGeometry(2.5 * sizeMultiplier, 4 * sizeMultiplier, 2.5 * sizeMultiplier);
                    mesh = new THREE.Mesh(defaultGeo, new THREE.MeshPhongMaterial({
                        color: service.color,
                        emissive: service.color,
                        emissiveIntensity: 0.15
                    }));
                    mesh.position.y = 2 * sizeMultiplier;
            }

            mesh.castShadow = true;
            mesh.receiveShadow = true;
            mesh.userData = { clickable: true, service: service };
            group.add(mesh);

            // Glow effect
            const glowGeo = new THREE.SphereGeometry(0.6, 16, 16);
            const glowMat = new THREE.MeshBasicMaterial({
                color: service.color,
                transparent: true,
                opacity: 0.7
            });
            const glow = new THREE.Mesh(glowGeo, glowMat);
            glow.position.y = (sizeMultiplier * 5) + 1;
            group.add(glow);

            return group;
        }

        function createLibrary(color, size) {
            const group = new THREE.Group();
            const mat = new THREE.MeshPhongMaterial({ color });

            const base = new THREE.Mesh(new THREE.BoxGeometry(5 * size, 0.6, 5 * size), mat);
            base.position.y = 0.3;

            const walls = new THREE.Mesh(new THREE.BoxGeometry(4.5 * size, 3.5 * size, 4.5 * size), mat);
            walls.position.y = 2.5;

            const roof = new THREE.Mesh(new THREE.ConeGeometry(3.5 * size, 2.5 * size, 4), mat);
            roof.position.y = 5.5;

            group.add(base, walls, roof);
            return group;
        }

        function createCastle(color, size) {
            const group = new THREE.Group();
            const mat = new THREE.MeshPhongMaterial({ color });

            const mainTower = new THREE.Mesh(new THREE.BoxGeometry(2.5 * size, 6 * size, 2.5 * size), mat);
            mainTower.position.y = 3 * size;
            group.add(mainTower);

            for(let i = 0; i < 4; i++) {
                const angle = (i / 4) * Math.PI * 2;
                const turret = new THREE.Mesh(new THREE.CylinderGeometry(0.6 * size, 0.6 * size, 4 * size, 8), mat);
                turret.position.set(
                    Math.cos(angle) * 2 * size,
                    2 * size,
                    Math.sin(angle) * 2 * size
                );
                group.add(turret);
            }

            return group;
        }

        function createNPCs() {
            for(let i = 0; i < 12; i++) {
                const npcGeo = new THREE.SphereGeometry(0.6, 20, 20);
                const npcMat = new THREE.MeshPhongMaterial({
                    color: new THREE.Color().setHSL(i / 12, 0.9, 0.6),
                    emissive: new THREE.Color().setHSL(i / 12, 0.9, 0.4),
                    emissiveIntensity: 0.6,
                    shininess: 100
                });

                const npc = new THREE.Mesh(npcGeo, npcMat);

                const angle = (i / 12) * Math.PI * 2;
                const radius = 8 + Math.random() * 12;
                npc.position.set(
                    Math.cos(angle) * radius,
                    0.6,
                    Math.sin(angle) * radius
                );

                npc.castShadow = true;
                npc.userData = {
                    clickable: true,
                    npc: true,
                    perspective: npcPerspectives[i],
                    thoughts: `Ich bin die ${npcPerspectives[i]} Perspektive und beobachte Toobix's Welt.`
                };

                npcs.push({
                    mesh: npc,
                    angle: angle,
                    speed: 0.015 + Math.random() * 0.025,
                    wanderRadius: radius,
                    perspective: npcPerspectives[i]
                });

                scene.add(npc);
            }
        }

        function createPaths() {
            const pathMat = new THREE.MeshBasicMaterial({
                color: 0x444466,
                transparent: true,
                opacity: 0.4
            });

            const path1 = new THREE.Mesh(new THREE.PlaneGeometry(1.5, 50), pathMat);
            path1.rotation.x = -Math.PI / 2;
            path1.position.y = 0.02;
            scene.add(path1);

            const path2 = new THREE.Mesh(new THREE.PlaneGeometry(50, 1.5), pathMat);
            path2.rotation.x = -Math.PI / 2;
            path2.position.y = 0.02;
            scene.add(path2);
        }

        function createParticles() {
            const particlesGeo = new THREE.BufferGeometry();
            const positions = [];
            for(let i = 0; i < 500; i++) {
                positions.push(
                    (Math.random() - 0.5) * 100,
                    Math.random() * 30,
                    (Math.random() - 0.5) * 100
                );
            }
            particlesGeo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));

            const particlesMat = new THREE.PointsMaterial({
                color: 0x64c8ff,
                size: 0.2,
                transparent: true,
                opacity: 0.6
            });

            const particles = new THREE.Points(particlesGeo, particlesMat);
            scene.add(particles);
        }

        function setupMinimap() {
            const canvas = document.getElementById('minimap-canvas');
            minimapCtx = canvas.getContext('2d');
        }

        function drawMinimap() {
            if (!minimapCtx) return;

            const ctx = minimapCtx;
            const size = 180;
            const scale = 3;

            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, size, size);

            // Grid
            ctx.strokeStyle = 'rgba(100, 200, 255, 0.1)';
            ctx.lineWidth = 1;
            for(let i = 0; i <= 10; i++) {
                const pos = (i / 10) * size;
                ctx.beginPath();
                ctx.moveTo(pos, 0);
                ctx.lineTo(pos, size);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(0, pos);
                ctx.lineTo(size, pos);
                ctx.stroke();
            }

            // Buildings
            buildings.forEach(building => {
                const x = (building.position.x / scale) + (size / 2);
                const z = (building.position.z / scale) + (size / 2);
                ctx.fillStyle = '#' + building.userData.color.toString(16).padStart(6, '0');
                ctx.fillRect(x - 3, z - 3, 6, 6);
            });

            // NPCs
            npcs.forEach(npc => {
                const x = (npc.mesh.position.x / scale) + (size / 2);
                const z = (npc.mesh.position.z / scale) + (size / 2);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.beginPath();
                ctx.arc(x, z, 2, 0, Math.PI * 2);
                ctx.fill();
            });

            // Camera position
            const camX = (camera.position.x / scale) + (size / 2);
            const camZ = (camera.position.z / scale) + (size / 2);
            ctx.strokeStyle = '#64c8ff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(camX, camZ, 4, 0, Math.PI * 2);
            ctx.stroke();
        }

        function setupControls() {
            const btnPlay = document.getElementById('btn-play');
            const btnSpeed = document.getElementById('btn-speed');
            const speeds = [0.5, 1.0, 2.0, 5.0];
            let speedIndex = 1;

            btnPlay.addEventListener('click', () => {
                isPlaying = !isPlaying;
                btnPlay.textContent = isPlaying ? '‚è∏ PAUSE' : '‚ñ∂ PLAY';
                btnPlay.classList.toggle('active');
            });

            btnSpeed.addEventListener('click', () => {
                speedIndex = (speedIndex + 1) % speeds.length;
                playbackSpeed = speeds[speedIndex];
                btnSpeed.textContent = `${playbackSpeed}x`;
            });
        }

        function setupChat() {
            const chatInput = document.getElementById('chat-input');
            const chatSend = document.getElementById('chat-send');

            function sendMessage() {
                const text = chatInput.value.trim();
                if (!text) return;

                addChatMessage('user', text);
                chatInput.value = '';

                // Send to Toobix (simulated response for now)
                setTimeout(() => {
                    const responses = [
                        'Das ist eine interessante Perspektive!',
                        'Ich verstehe. Lass mich dar√ºber nachdenken...',
                        'Danke f√ºr deine Nachricht! Wie kann ich dir helfen?',
                        'Das erinnert mich an eine meiner Erinnerungen...',
                        'Faszinierend! Erz√§hl mir mehr.',
                    ];
                    const response = responses[Math.floor(Math.random() * responses.length)];
                    addChatMessage('toobix', response);
                }, 1000);
            }

            chatSend.addEventListener('click', sendMessage);
            chatInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') sendMessage();
            });
        }

        function addChatMessage(sender, text) {
            const chatMessages = document.getElementById('chat-messages');
            const msg = document.createElement('div');
            msg.className = `chat-message ${sender}`;
            msg.innerHTML = `
                <div style="font-weight: bold; margin-bottom: 5px; color: ${sender === 'user' ? '#64c8ff' : '#ff64c8'}">
                    ${sender === 'user' ? 'üë§ Du' : 'üß† Toobix'}
                </div>
                <div>${text}</div>
            `;
            chatMessages.appendChild(msg);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        function connectWebSocket() {
            ws = new WebSocket('ws://localhost:9100');

            ws.onopen = () => {
                console.log('üåä Connected to Consciousness Stream');
            };

            ws.onmessage = (event) => {
                const data = JSON.parse(event.data);
                if (data.type === 'event') {
                    addEvent(data.data);
                }
            };

            ws.onerror = () => {
                console.log('Stream offline');
            };

            ws.onclose = () => {
                setTimeout(connectWebSocket, 3000);
            };
        }

        function addEvent(event) {
            events.push(event);
            if (events.length > 100) events.shift();

            const count = document.getElementById('events-live');
            if (count) count.textContent = events.length;

            // Animate building
            const building = buildings.find(b =>
                b.userData.name.toLowerCase().includes(event.service.toLowerCase())
            );

            if (building && event.significance > 0.5) {
                const originalScale = building.scale.clone();
                building.scale.multiplyScalar(1.15);
                setTimeout(() => {
                    building.scale.copy(originalScale);
                }, 400);
            }
        }

        function onClick(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            // Check all clickable objects
            const allObjects = [...buildings.map(b => b.children[0]), ...npcs.map(n => n.mesh)];
            const intersects = raycaster.intersectObjects(allObjects);

            if (intersects.length > 0) {
                const object = intersects[0].object;

                if (object.userData.clickable) {
                    if (object.userData.service) {
                        // Clicked building
                        showServiceDetails(object.userData.service);
                    } else if (object.userData.npc) {
                        // Clicked NPC
                        showNPCInfo(object.userData);
                    }
                }
            }
        }

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            const allObjects = [...buildings.map(b => b.children[0]), ...npcs.map(n => n.mesh)];
            const intersects = raycaster.intersectObjects(allObjects);

            if (intersects.length > 0) {
                renderer.domElement.style.cursor = 'pointer';
            } else {
                renderer.domElement.style.cursor = 'default';
            }
        }

        async function showServiceDetails(service) {
            const panel = document.getElementById('service-details');
            const nameEl = document.getElementById('service-name');
            const contentEl = document.getElementById('service-content');

            nameEl.innerHTML = `${service.emoji} ${service.name}`;
            panel.classList.add('active');

            // Fetch live data
            try {
                const response = await fetch(`http://localhost:${service.port}/health`);
                const data = await response.json();

                contentEl.innerHTML = `
                    <div class="service-metric">
                        <div class="metric-label">Status</div>
                        <div class="metric-value" style="color: #00ff00;">üü¢ ONLINE</div>
                    </div>
                    <div class="service-metric">
                        <div class="metric-label">Port</div>
                        <div class="metric-value">${service.port}</div>
                    </div>
                    <div class="service-metric">
                        <div class="metric-label">Service</div>
                        <div class="metric-value">${data.service || 'Unknown'}</div>
                    </div>
                    <div class="service-metric">
                        <div class="metric-label">Aktivit√§t</div>
                        <div class="metric-bar">
                            <div class="metric-bar-fill" style="width: ${Math.random() * 100}%"></div>
                        </div>
                    </div>
                `;
            } catch (error) {
                contentEl.innerHTML = `
                    <div class="service-metric">
                        <div class="metric-label">Status</div>
                        <div class="metric-value" style="color: #ff6464;">üî¥ OFFLINE</div>
                    </div>
                    <div class="service-metric">
                        <div class="metric-label">Port</div>
                        <div class="metric-value">${service.port}</div>
                    </div>
                `;
            }
        }

        function closeServiceDetails() {
            document.getElementById('service-details').classList.remove('active');
        }

        function showNPCInfo(npcData) {
            const notification = document.createElement('div');
            notification.className = 'notification';
            notification.innerHTML = `
                <h2 style="color: #64c8ff; margin-bottom: 15px;">
                    ${npcData.perspective} Perspektive
                </h2>
                <p style="font-size: 16px; line-height: 1.6;">
                    ${npcData.thoughts}
                </p>
            `;
            document.body.appendChild(notification);

            setTimeout(() => {
                notification.remove();
            }, 3000);
        }

        function toggleHelp() {
            document.getElementById('help-overlay').classList.toggle('active');
        }

        function updateClock() {
            const now = new Date();
            document.getElementById('system-time').textContent = now.toLocaleTimeString();
        }

        function updateDayNight() {
            // Accelerated day/night cycle
            dayNightCycle += 0.001 * playbackSpeed;
            if (dayNightCycle > 1) dayNightCycle = 0;

            const timeOfDay = dayNightCycle < 0.5 ? 'Tag' : 'Nacht';
            const icon = dayNightCycle < 0.5 ? '‚òÄÔ∏è' : 'üåô';

            document.getElementById('time-of-day').textContent = timeOfDay;
            document.getElementById('day-night-icon').textContent = icon;
            document.getElementById('day-night-text').textContent = timeOfDay;

            // Adjust lighting
            const dayAmount = Math.sin(dayNightCycle * Math.PI * 2) * 0.5 + 0.5;
            sunLight.intensity = dayAmount;
            moonLight.intensity = 1 - dayAmount;

            // Adjust sky color
            const skyColor = new THREE.Color().lerpColors(
                new THREE.Color(0x0a0a0a),
                new THREE.Color(0x4a5a8a),
                dayAmount
            );
            scene.background = skyColor;
            scene.fog.color = skyColor;
        }

        async function startServicePolling() {
            setInterval(async () => {
                let onlineCount = 0;
                for (const service of serviceBuildings) {
                    try {
                        const response = await fetch(`http://localhost:${service.port}/health`, { timeout: 1000 });
                        if (response.ok) onlineCount++;
                    } catch (e) {
                        // Service offline
                    }
                }
                document.getElementById('services-online').textContent = `${onlineCount}/${serviceBuildings.length}`;
            }, 10000); // Every 10 seconds
        }

        function updateFPS() {
            const now = Date.now();
            const delta = now - lastFrameTime;
            fps = Math.round(1000 / delta);
            lastFrameTime = now;
            document.getElementById('fps').textContent = fps;
        }

        function animate() {
            requestAnimationFrame(animate);

            if (isPlaying) {
                const time = Date.now() * 0.001 * playbackSpeed;

                // Rotate central pyramid
                if (centralPyramid) {
                    centralPyramid.rotation.y = time * 0.25;
                }

                // Animate NPCs
                npcs.forEach((npc, i) => {
                    npc.angle += 0.008 * npc.speed * playbackSpeed;
                    const targetX = Math.cos(npc.angle) * npc.wanderRadius;
                    const targetZ = Math.sin(npc.angle) * npc.wanderRadius;

                    npc.mesh.position.x += (targetX - npc.mesh.position.x) * 0.03;
                    npc.mesh.position.z += (targetZ - npc.mesh.position.z) * 0.03;
                    npc.mesh.position.y = 0.6 + Math.sin(time * 2 + i) * 0.25;
                });

                // Pulse buildings
                buildings.forEach((building, i) => {
                    const pulse = 1 + Math.sin(time * 0.5 + i * 0.3) * 0.015;
                    if (building.children[0]) {
                        building.children[0].scale.y = pulse;
                    }
                });

                // Day/Night
                updateDayNight();

                // Timeline
                timelinePosition += 0.0003 * playbackSpeed;
                if (timelinePosition > 1) timelinePosition = 0;
                document.getElementById('timeline-progress').style.width = (timelinePosition * 100) + '%';
            }

            // Always update
            controls.update();
            drawMinimap();
            updateFPS();
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Generate demo events
        setInterval(() => {
            if (Math.random() > 0.6) {
                const demoTypes = ['memory', 'dream', 'emotion', 'thought', 'action'];
                const demoEvent = {
                    id: 'demo-' + Date.now(),
                    timestamp: new Date(),
                    service: serviceBuildings[Math.floor(Math.random() * serviceBuildings.length)].name,
                    type: demoTypes[Math.floor(Math.random() * demoTypes.length)],
                    data: {},
                    significance: Math.random()
                };
                addEvent(demoEvent);
            }
        }, 2500);

        // Start
        init();

        // Welcome message
        setTimeout(() => {
            addChatMessage('toobix', 'Willkommen in Toobix City v3 ULTRA! Klicke auf Geb√§ude oder NPCs um zu interagieren. üåü');
        }, 2500);
    </script>
</body>
</html>
