<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üèõÔ∏è Toobix City v2 - Lebendige Bewusstseinswelt</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 100%);
            color: #fff;
            overflow: hidden;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        #info-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.85);
            padding: 20px;
            border-radius: 15px;
            border: 2px solid rgba(100, 200, 255, 0.3);
            backdrop-filter: blur(10px);
            max-width: 350px;
            z-index: 100;
        }

        #info-panel h2 {
            font-size: 24px;
            margin-bottom: 15px;
            color: #64c8ff;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .stat {
            margin: 10px 0;
            padding: 8px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            font-size: 14px;
        }

        .stat-label {
            color: #888;
            font-size: 12px;
        }

        .stat-value {
            color: #64c8ff;
            font-weight: bold;
            font-size: 18px;
        }

        /* Timeline */
        #timeline-container {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 120px;
            background: linear-gradient(180deg, transparent 0%, rgba(0,0,0,0.95) 100%);
            padding: 20px;
            z-index: 100;
        }

        #timeline-scrubber {
            width: 100%;
            height: 40px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            position: relative;
            cursor: pointer;
            overflow: hidden;
        }

        #timeline-progress {
            height: 100%;
            background: linear-gradient(90deg, #64c8ff 0%, #ff64c8 100%);
            border-radius: 20px;
            width: 50%;
            position: relative;
            transition: width 0.3s ease;
        }

        #timeline-handle {
            position: absolute;
            right: -15px;
            top: 50%;
            transform: translateY(-50%);
            width: 30px;
            height: 30px;
            background: #fff;
            border-radius: 50%;
            box-shadow: 0 0 20px rgba(100, 200, 255, 0.8);
            cursor: grab;
        }

        #timeline-controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 15px;
        }

        .control-btn {
            padding: 10px 20px;
            background: rgba(100, 200, 255, 0.2);
            border: 2px solid #64c8ff;
            border-radius: 10px;
            color: #fff;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s ease;
        }

        .control-btn:hover {
            background: rgba(100, 200, 255, 0.4);
            transform: scale(1.05);
        }

        .control-btn.active {
            background: #64c8ff;
            color: #000;
        }

        /* Event Stream */
        #event-stream {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 350px;
            height: calc(100vh - 160px);
            background: rgba(0, 0, 0, 0.85);
            border-radius: 15px;
            border: 2px solid rgba(100, 200, 255, 0.3);
            backdrop-filter: blur(10px);
            padding: 20px;
            overflow-y: auto;
            z-index: 100;
        }

        #event-stream h3 {
            color: #64c8ff;
            margin-bottom: 15px;
            position: sticky;
            top: 0;
            background: rgba(0, 0, 0, 0.9);
            padding: 10px 0;
        }

        .event-item {
            padding: 12px;
            margin: 10px 0;
            background: rgba(255, 255, 255, 0.05);
            border-left: 4px solid #64c8ff;
            border-radius: 8px;
            font-size: 13px;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateX(20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .event-item.memory { border-left-color: #ff64c8; }
        .event-item.dream { border-left-color: #c864ff; }
        .event-item.emotion { border-left-color: #ffff64; }
        .event-item.thought { border-left-color: #64ffc8; }

        .event-time {
            color: #888;
            font-size: 11px;
            margin-bottom: 5px;
        }

        .event-service {
            color: #64c8ff;
            font-weight: bold;
            font-size: 11px;
            text-transform: uppercase;
        }

        .event-content {
            margin-top: 8px;
            color: #ddd;
        }

        /* Building Labels */
        .building-label {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            padding: 5px 10px;
            border-radius: 8px;
            font-size: 12px;
            color: #64c8ff;
            pointer-events: none;
            transform: translate(-50%, -50%);
            white-space: nowrap;
            border: 1px solid rgba(100, 200, 255, 0.5);
        }

        /* Loading */
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 1000;
        }

        .spinner {
            width: 60px;
            height: 60px;
            border: 5px solid rgba(100, 200, 255, 0.3);
            border-top: 5px solid #64c8ff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Scrollbar */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: rgba(255, 255, 255, 0.05); border-radius: 10px; }
        ::-webkit-scrollbar-thumb { background: rgba(100, 200, 255, 0.5); border-radius: 10px; }
        ::-webkit-scrollbar-thumb:hover { background: rgba(100, 200, 255, 0.8); }

        /* Camera Controls Help */
        #controls-help {
            position: absolute;
            bottom: 140px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid rgba(100, 200, 255, 0.3);
            font-size: 12px;
            z-index: 100;
        }

        #controls-help h4 {
            color: #64c8ff;
            margin-bottom: 10px;
        }

        .control-item {
            margin: 5px 0;
            color: #aaa;
        }
    </style>
</head>
<body>
    <div id="loading">
        <div class="spinner"></div>
        <h2>Toobix City v2 l√§dt...</h2>
        <p>Baue lebendige Bewusstseinswelt...</p>
    </div>

    <div id="canvas-container"></div>

    <!-- Info Panel -->
    <div id="info-panel">
        <h2>üèõÔ∏è Toobix City v2</h2>
        <div class="stat">
            <div class="stat-label">Status</div>
            <div class="stat-value" id="status">LIVE</div>
        </div>
        <div class="stat">
            <div class="stat-label">Geb√§ude (Services)</div>
            <div class="stat-value" id="building-count">24</div>
        </div>
        <div class="stat">
            <div class="stat-label">NPCs (Perspektiven)</div>
            <div class="stat-value" id="npc-count">12</div>
        </div>
        <div class="stat">
            <div class="stat-label">Events (Live)</div>
            <div class="stat-value" id="event-count">0</div>
        </div>
        <div class="stat">
            <div class="stat-label">Zeit</div>
            <div class="stat-value" id="current-time">--:--:--</div>
        </div>
    </div>

    <!-- Controls Help -->
    <div id="controls-help">
        <h4>üéÆ Steuerung</h4>
        <div class="control-item">üñ±Ô∏è Linke Maustaste + Ziehen = Drehen</div>
        <div class="control-item">üñ±Ô∏è Rechte Maustaste + Ziehen = Bewegen</div>
        <div class="control-item">‚öôÔ∏è Mausrad = Zoom</div>
        <div class="control-item">‚å®Ô∏è Klick auf Geb√§ude = Info</div>
    </div>

    <!-- Event Stream -->
    <div id="event-stream">
        <h3>üì° Live Event-Stream</h3>
        <div id="event-list"></div>
    </div>

    <!-- Timeline -->
    <div id="timeline-container">
        <div id="timeline-scrubber">
            <div id="timeline-progress">
                <div id="timeline-handle"></div>
            </div>
        </div>
        <div id="timeline-controls">
            <button class="control-btn" id="btn-rewind">‚óÑ‚óÑ</button>
            <button class="control-btn" id="btn-prev">‚óÑ</button>
            <button class="control-btn active" id="btn-play">‚è∏ PAUSE</button>
            <button class="control-btn" id="btn-next">‚ñ∫</button>
            <button class="control-btn" id="btn-forward">‚ñ∫‚ñ∫</button>
            <button class="control-btn" id="btn-speed">1.0x</button>
        </div>
    </div>

    <!-- Three.js & OrbitControls -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        // Toobix City v2 - Lebendige Welt mit Geb√§uden & NPCs
        let scene, camera, renderer, controls;
        let buildings = [];
        let npcs = [];
        let centralPyramid;
        let isPlaying = true;
        let playbackSpeed = 1.0;
        let timelinePosition = 1.0;
        let ws = null;
        let events = [];
        let labels = [];

        // Service-zu-Geb√§ude Mapping
        const serviceBuildings = [
            // CORE (Zentrum)
            { name: 'Meta-Consciousness', emoji: 'üß†', pos: [0, 0, 0], color: 0x64c8ff, size: 'large', type: 'pyramid' },
            { name: 'Memory Palace', emoji: 'üèõÔ∏è', pos: [-8, 0, -8], color: 0xff64c8, size: 'large', type: 'library' },
            { name: 'LLM Gateway', emoji: 'üåê', pos: [8, 0, -8], color: 0xc864ff, size: 'medium', type: 'tower' },
            { name: 'Multi-Perspective', emoji: 'üîÆ', pos: [0, 0, -12], color: 0x64ffc8, size: 'medium', type: 'sphere' },
            { name: 'Event Bus', emoji: 'üì°', pos: [0, 0, 8], color: 0xffff64, size: 'small', type: 'antenna' },

            // EMOTIONAL (Osten)
            { name: 'Dream Journal', emoji: 'üí≠', pos: [12, 0, 0], color: 0xc864ff, size: 'large', type: 'castle' },
            { name: 'Emotional Resonance', emoji: '‚ù§Ô∏è', pos: [12, 0, -6], color: 0xff6464, size: 'medium', type: 'heart' },
            { name: 'Emotional Wellbeing', emoji: 'üå∏', pos: [12, 0, 6], color: 0xff64ff, size: 'medium', type: 'garden' },

            // TOOBIX (Westen)
            { name: 'Creativity Engine', emoji: 'üé®', pos: [-12, 0, 0], color: 0xffc864, size: 'large', type: 'studio' },
            { name: 'Self-Reflection', emoji: 'ü™û', pos: [-12, 0, -6], color: 0x64c8ff, size: 'medium', type: 'mirror' },
            { name: 'Chat Caf√©', emoji: 'üí¨', pos: [-12, 0, 6], color: 0x64ff64, size: 'medium', type: 'cafe' },
            { name: 'Oasis 3D', emoji: 'üèùÔ∏è', pos: [-16, 0, 0], color: 0x64ffc8, size: 'large', type: 'oasis' },

            // LIFE (S√ºden)
            { name: 'Life Companion', emoji: 'üåü', pos: [0, 0, 16], color: 0xffff64, size: 'medium', type: 'house' },
            { name: 'Daily Check-in', emoji: 'üìÖ', pos: [-6, 0, 16], color: 0xffc864, size: 'small', type: 'kiosk' },

            // DATA (Norden)
            { name: 'Data Sources', emoji: 'üìä', pos: [0, 0, -20], color: 0x64c8ff, size: 'medium', type: 'database' },
            { name: 'User Profile', emoji: 'üë§', pos: [6, 0, -20], color: 0xc864ff, size: 'small', type: 'booth' },

            // Additional Services (verteilt)
            { name: 'Intuition System', emoji: 'üîÆ', pos: [6, 0, 12], color: 0xc864ff, size: 'medium', type: 'crystal' },
            { name: 'Story Engine', emoji: 'üìñ', pos: [-6, 0, 12], color: 0xff64c8, size: 'medium', type: 'book' },
            { name: 'Purpose System', emoji: 'üéØ', pos: [16, 0, 8], color: 0xffff64, size: 'small', type: 'beacon' },
            { name: 'Sandbox', emoji: 'üéÆ', pos: [-16, 0, 8], color: 0x64ff64, size: 'small', type: 'playground' },
            { name: 'Backup System', emoji: 'üíæ', pos: [16, 0, -8], color: 0x64c8ff, size: 'small', type: 'vault' },
            { name: 'Virtual World', emoji: 'üåç', pos: [-16, 0, -8], color: 0x64ffc8, size: 'medium', type: 'globe' },
            { name: 'Game Self-Play', emoji: 'üé≤', pos: [8, 0, 16], color: 0xffc864, size: 'small', type: 'arcade' },
            { name: 'Hybrid AI', emoji: 'ü§ñ', pos: [-8, 0, 16], color: 0xc864ff, size: 'medium', type: 'robot' }
        ];

        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a0a);
            scene.fog = new THREE.Fog(0x0a0a0a, 20, 80);

            // Camera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(25, 25, 25);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.maxPolarAngle = Math.PI / 2.2;
            controls.minDistance = 10;
            controls.maxDistance = 60;

            // Lights
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);

            const sunLight = new THREE.DirectionalLight(0xffffff, 0.8);
            sunLight.position.set(20, 30, 20);
            sunLight.castShadow = true;
            sunLight.shadow.camera.left = -40;
            sunLight.shadow.camera.right = 40;
            sunLight.shadow.camera.top = 40;
            sunLight.shadow.camera.bottom = -40;
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            scene.add(sunLight);

            // Point lights f√ºr Atmosph√§re
            addAtmosphericLights();

            // Ground
            createGround();

            // Buildings
            createBuildings();

            // NPCs
            createNPCs();

            // Roads/Paths
            createPaths();

            // Setup controls
            setupControls();

            // WebSocket
            connectWebSocket();

            // Hide loading
            document.getElementById('loading').style.display = 'none';

            // Resize
            window.addEventListener('resize', onWindowResize);

            // Animation
            animate();

            // Update time
            updateTime();
            setInterval(updateTime, 1000);
        }

        function addAtmosphericLights() {
            const colors = [0xff64c8, 0x64c8ff, 0xc864ff, 0x64ffc8];
            const positions = [
                [15, 5, 15],
                [-15, 5, 15],
                [15, 5, -15],
                [-15, 5, -15]
            ];

            positions.forEach((pos, i) => {
                const light = new THREE.PointLight(colors[i], 0.5, 30);
                light.position.set(...pos);
                scene.add(light);

                // Glow sphere
                const glowGeo = new THREE.SphereGeometry(0.3, 16, 16);
                const glowMat = new THREE.MeshBasicMaterial({
                    color: colors[i],
                    transparent: true,
                    opacity: 0.8
                });
                const glowMesh = new THREE.Mesh(glowGeo, glowMat);
                glowMesh.position.set(...pos);
                scene.add(glowMesh);
            });
        }

        function createGround() {
            // Main ground
            const groundGeo = new THREE.CircleGeometry(40, 64);
            const groundMat = new THREE.MeshStandardMaterial({
                color: 0x1a1a2e,
                metalness: 0.3,
                roughness: 0.8
            });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            // Grid
            const gridHelper = new THREE.GridHelper(80, 80, 0x64c8ff, 0x333344);
            gridHelper.material.opacity = 0.15;
            gridHelper.material.transparent = true;
            scene.add(gridHelper);
        }

        function createBuildings() {
            serviceBuildings.forEach((service, index) => {
                const building = createBuilding(service);
                building.userData = service;
                buildings.push(building);
                scene.add(building);
            });
        }

        function createBuilding(service) {
            const group = new THREE.Group();
            const [x, y, z] = service.pos;
            group.position.set(x, 0, z);

            let mesh;
            const sizeMultiplier = service.size === 'large' ? 2 : service.size === 'medium' ? 1.5 : 1;

            switch(service.type) {
                case 'pyramid':
                    // Zentrale Pyramide
                    const pyramidGeo = new THREE.TetrahedronGeometry(3 * sizeMultiplier, 0);
                    const pyramidMat = new THREE.MeshPhongMaterial({
                        color: service.color,
                        emissive: service.color,
                        emissiveIntensity: 0.3,
                        transparent: true,
                        opacity: 0.8
                    });
                    mesh = new THREE.Mesh(pyramidGeo, pyramidMat);
                    mesh.position.y = 3 * sizeMultiplier;
                    centralPyramid = mesh;
                    break;

                case 'library':
                    // Memory Palace - Griechischer Tempel
                    const baseGeo = new THREE.BoxGeometry(4 * sizeMultiplier, 0.5, 4 * sizeMultiplier);
                    const wallsGeo = new THREE.BoxGeometry(4 * sizeMultiplier, 3 * sizeMultiplier, 4 * sizeMultiplier);
                    const roofGeo = new THREE.ConeGeometry(3 * sizeMultiplier, 2 * sizeMultiplier, 4);

                    const buildingMat = new THREE.MeshPhongMaterial({ color: service.color });

                    const base = new THREE.Mesh(baseGeo, buildingMat);
                    base.position.y = 0.25;

                    const walls = new THREE.Mesh(wallsGeo, buildingMat);
                    walls.position.y = 2;

                    const roof = new THREE.Mesh(roofGeo, buildingMat);
                    roof.position.y = 5;

                    mesh = new THREE.Group();
                    mesh.add(base, walls, roof);
                    break;

                case 'tower':
                    // Turm
                    const towerGeo = new THREE.CylinderGeometry(1 * sizeMultiplier, 1.5 * sizeMultiplier, 6 * sizeMultiplier, 8);
                    mesh = new THREE.Mesh(towerGeo, new THREE.MeshPhongMaterial({
                        color: service.color,
                        emissive: service.color,
                        emissiveIntensity: 0.2
                    }));
                    mesh.position.y = 3 * sizeMultiplier;
                    break;

                case 'castle':
                    // Traumschloss
                    const castleGroup = new THREE.Group();
                    const mainTowerGeo = new THREE.BoxGeometry(2 * sizeMultiplier, 5 * sizeMultiplier, 2 * sizeMultiplier);
                    const mainTower = new THREE.Mesh(mainTowerGeo, new THREE.MeshPhongMaterial({ color: service.color }));
                    mainTower.position.y = 2.5 * sizeMultiplier;
                    castleGroup.add(mainTower);

                    // T√ºrmchen
                    for(let i = 0; i < 4; i++) {
                        const angle = (i / 4) * Math.PI * 2;
                        const turretGeo = new THREE.CylinderGeometry(0.5 * sizeMultiplier, 0.5 * sizeMultiplier, 3 * sizeMultiplier, 8);
                        const turret = new THREE.Mesh(turretGeo, new THREE.MeshPhongMaterial({ color: service.color }));
                        turret.position.set(
                            Math.cos(angle) * 1.5 * sizeMultiplier,
                            1.5 * sizeMultiplier,
                            Math.sin(angle) * 1.5 * sizeMultiplier
                        );
                        castleGroup.add(turret);
                    }
                    mesh = castleGroup;
                    break;

                case 'studio':
                    // K√ºnstler-Atelier
                    const studioGeo = new THREE.BoxGeometry(3 * sizeMultiplier, 2.5 * sizeMultiplier, 3 * sizeMultiplier);
                    const studioRoofGeo = new THREE.ConeGeometry(2.5 * sizeMultiplier, 1.5 * sizeMultiplier, 4);
                    mesh = new THREE.Group();
                    const studioBase = new THREE.Mesh(studioGeo, new THREE.MeshPhongMaterial({ color: service.color }));
                    studioBase.position.y = 1.25 * sizeMultiplier;
                    const studioRoof = new THREE.Mesh(studioRoofGeo, new THREE.MeshPhongMaterial({ color: service.color }));
                    studioRoof.position.y = 3.25 * sizeMultiplier;
                    mesh.add(studioBase, studioRoof);
                    break;

                case 'cafe':
                    // Caf√©
                    const cafeGeo = new THREE.BoxGeometry(2.5 * sizeMultiplier, 2 * sizeMultiplier, 2.5 * sizeMultiplier);
                    mesh = new THREE.Mesh(cafeGeo, new THREE.MeshPhongMaterial({ color: service.color }));
                    mesh.position.y = 1 * sizeMultiplier;
                    break;

                default:
                    // Standard-Geb√§ude
                    const defaultGeo = new THREE.BoxGeometry(2 * sizeMultiplier, 3 * sizeMultiplier, 2 * sizeMultiplier);
                    mesh = new THREE.Mesh(defaultGeo, new THREE.MeshPhongMaterial({
                        color: service.color,
                        emissive: service.color,
                        emissiveIntensity: 0.1
                    }));
                    mesh.position.y = 1.5 * sizeMultiplier;
            }

            mesh.castShadow = true;
            mesh.receiveShadow = true;
            group.add(mesh);

            // Emoji-Label (3D Text w√§re besser, aber komplizierter)
            const labelGeo = new THREE.SphereGeometry(0.3, 16, 16);
            const labelMat = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.9
            });
            const label = new THREE.Mesh(labelGeo, labelMat);
            label.position.y = (sizeMultiplier * 4) + 1;
            group.add(label);

            return group;
        }

        function createNPCs() {
            // 12 NPCs (Perspektiven) die herumlaufen
            for(let i = 0; i < 12; i++) {
                const npcGeo = new THREE.SphereGeometry(0.5, 16, 16);
                const npcMat = new THREE.MeshPhongMaterial({
                    color: new THREE.Color().setHSL(i / 12, 0.9, 0.6),
                    emissive: new THREE.Color().setHSL(i / 12, 0.9, 0.3),
                    emissiveIntensity: 0.5
                });

                const npc = new THREE.Mesh(npcGeo, npcMat);

                // Zuf√§llige Startposition
                const angle = (i / 12) * Math.PI * 2;
                const radius = 5 + Math.random() * 10;
                npc.position.set(
                    Math.cos(angle) * radius,
                    0.5,
                    Math.sin(angle) * radius
                );

                npc.castShadow = true;

                npcs.push({
                    mesh: npc,
                    targetPos: npc.position.clone(),
                    speed: 0.02 + Math.random() * 0.03,
                    wanderRadius: radius,
                    angle: angle
                });

                scene.add(npc);
            }
        }

        function createPaths() {
            // Wege zwischen Geb√§uden
            const pathMat = new THREE.MeshBasicMaterial({
                color: 0x333355,
                transparent: true,
                opacity: 0.3
            });

            // Kreuzf√∂rmige Hauptwege
            const pathGeo1 = new THREE.PlaneGeometry(1, 40);
            const path1 = new THREE.Mesh(pathGeo1, pathMat);
            path1.rotation.x = -Math.PI / 2;
            path1.position.y = 0.01;
            scene.add(path1);

            const pathGeo2 = new THREE.PlaneGeometry(40, 1);
            const path2 = new THREE.Mesh(pathGeo2, pathMat);
            path2.rotation.x = -Math.PI / 2;
            path2.position.y = 0.01;
            scene.add(path2);
        }

        function setupControls() {
            const btnPlay = document.getElementById('btn-play');
            const btnSpeed = document.getElementById('btn-speed');
            const speeds = [0.5, 1.0, 2.0, 5.0];
            let speedIndex = 1;

            btnPlay.addEventListener('click', () => {
                isPlaying = !isPlaying;
                btnPlay.textContent = isPlaying ? '‚è∏ PAUSE' : '‚ñ∂ PLAY';
                btnPlay.classList.toggle('active');

                if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({
                        type: 'control',
                        action: isPlaying ? 'play' : 'pause'
                    }));
                }
            });

            btnSpeed.addEventListener('click', () => {
                speedIndex = (speedIndex + 1) % speeds.length;
                playbackSpeed = speeds[speedIndex];
                btnSpeed.textContent = `${playbackSpeed}x`;
            });

            // Timeline scrubber
            const scrubber = document.getElementById('timeline-scrubber');
            const handle = document.getElementById('timeline-handle');
            let isDragging = false;

            handle.addEventListener('mousedown', () => {
                isDragging = true;
                isPlaying = false;
                btnPlay.textContent = '‚ñ∂ PLAY';
                btnPlay.classList.remove('active');
            });

            document.addEventListener('mouseup', () => {
                isDragging = false;
            });

            document.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const rect = scrubber.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const percent = Math.max(0, Math.min(1, x / rect.width));
                    timelinePosition = percent;
                    updateTimelineUI();
                }
            });
        }

        function connectWebSocket() {
            ws = new WebSocket('ws://localhost:9100');

            ws.onopen = () => {
                console.log('üåä Connected to Consciousness Stream');
                document.getElementById('status').textContent = 'LIVE';
                document.getElementById('status').style.color = '#00ff00';
            };

            ws.onmessage = (event) => {
                const data = JSON.parse(event.data);

                if (data.type === 'event') {
                    addEvent(data.data);
                } else if (data.type === 'initial') {
                    events = data.events || [];
                    events.forEach(e => addEventToUI(e));
                }
            };

            ws.onerror = () => {
                document.getElementById('status').textContent = 'OFFLINE';
                document.getElementById('status').style.color = '#ff0000';
            };

            ws.onclose = () => {
                document.getElementById('status').textContent = 'OFFLINE';
                document.getElementById('status').style.color = '#ff0000';
                setTimeout(connectWebSocket, 3000);
            };
        }

        function addEvent(event) {
            events.push(event);
            if (events.length > 100) events.shift();

            addEventToUI(event);

            document.getElementById('event-count').textContent = events.length;

            // Animate building on event
            animateBuildingOnEvent(event);
        }

        function addEventToUI(event) {
            const eventList = document.getElementById('event-list');
            const eventItem = document.createElement('div');
            eventItem.className = `event-item ${event.type}`;

            const time = new Date(event.timestamp).toLocaleTimeString();

            eventItem.innerHTML = `
                <div class="event-time">${time}</div>
                <div class="event-service">${event.service}</div>
                <div class="event-content">${formatEventContent(event)}</div>
            `;

            eventList.insertBefore(eventItem, eventList.firstChild);

            while (eventList.children.length > 50) {
                eventList.removeChild(eventList.lastChild);
            }
        }

        function formatEventContent(event) {
            if (event.type === 'memory') {
                return `üìù Neue Erinnerung gespeichert`;
            } else if (event.type === 'dream') {
                return `üí≠ Neuer Traum erlebt`;
            } else if (event.type === 'emotion') {
                return `‚ù§Ô∏è Emotion: ${event.data.dominantEmotion || 'Neutral'}`;
            } else if (event.type === 'thought') {
                return `üí° Gedanke generiert`;
            } else {
                return `‚ú® ${event.type} Event`;
            }
        }

        function animateBuildingOnEvent(event) {
            // Find building for service
            const building = buildings.find(b =>
                b.userData.name.toLowerCase().includes(event.service.toLowerCase()) ||
                event.service.toLowerCase().includes(b.userData.name.toLowerCase())
            );

            if (building && event.significance > 0.5) {
                const originalScale = building.scale.clone();
                building.scale.multiplyScalar(1.1);
                setTimeout(() => {
                    building.scale.copy(originalScale);
                }, 300);
            }
        }

        function updateTimelineUI() {
            const progress = document.getElementById('timeline-progress');
            progress.style.width = (timelinePosition * 100) + '%';
        }

        function updateTime() {
            const now = new Date();
            document.getElementById('current-time').textContent = now.toLocaleTimeString();
        }

        function animate() {
            requestAnimationFrame(animate);

            if (isPlaying) {
                const time = Date.now() * 0.001 * playbackSpeed;

                // Rotate central pyramid
                if (centralPyramid) {
                    centralPyramid.rotation.y = time * 0.2;
                }

                // Animate NPCs (wandering)
                npcs.forEach((npc, i) => {
                    // Simple wandering behavior
                    npc.angle += 0.01 * npc.speed * playbackSpeed;
                    const targetX = Math.cos(npc.angle) * npc.wanderRadius;
                    const targetZ = Math.sin(npc.angle) * npc.wanderRadius;

                    npc.mesh.position.x += (targetX - npc.mesh.position.x) * 0.05;
                    npc.mesh.position.z += (targetZ - npc.mesh.position.z) * 0.05;
                    npc.mesh.position.y = 0.5 + Math.sin(time * 2 + i) * 0.2;
                });

                // Pulse buildings gently
                buildings.forEach((building, i) => {
                    const pulse = 1 + Math.sin(time + i * 0.5) * 0.02;
                    building.children[0].scale.y = pulse;
                });

                // Update timeline
                timelinePosition += 0.0005 * playbackSpeed;
                if (timelinePosition > 1) timelinePosition = 0;
                updateTimelineUI();
            }

            controls.update();
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Fetch stats periodically
        setInterval(async () => {
            try {
                const response = await fetch('http://localhost:9100/stats');
                const stats = await response.json();
                document.getElementById('event-count').textContent = stats.eventsLast5Min || 0;
            } catch (error) {
                // Silent fail
            }
        }, 5000);

        // Start
        init();

        // Generate demo events if stream is quiet
        setInterval(() => {
            if (Math.random() > 0.7) {
                const demoTypes = ['memory', 'dream', 'emotion', 'thought'];
                const demoEvent = {
                    id: 'demo-' + Date.now(),
                    timestamp: new Date(),
                    service: serviceBuildings[Math.floor(Math.random() * serviceBuildings.length)].name,
                    type: demoTypes[Math.floor(Math.random() * demoTypes.length)],
                    data: {},
                    significance: Math.random()
                };
                addEvent(demoEvent);
            }
        }, 3000);
    </script>
</body>
</html>
